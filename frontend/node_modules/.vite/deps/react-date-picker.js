import {
  require_react_dom
} from "./chunk-XHCDW3LY.js";
import {
  clsx_default,
  dist_default,
  dist_default2,
  getDate,
  getDayEnd,
  getDayStart,
  getDaysInMonth,
  getDecadeEnd,
  getDecadeStart,
  getISOLocalDate,
  getISOLocalMonth,
  getMonthEnd,
  getMonthHuman,
  getMonthStart,
  getYear,
  getYearEnd,
  getYearStart
} from "./chunk-2RG6J5NY.js";
import {
  require_jsx_runtime
} from "./chunk-LH2JL3P5.js";
import {
  __commonJS,
  __toESM,
  require_react
} from "./chunk-AMZ7Q62Q.js";

// node_modules/warning/warning.js
var require_warning = __commonJS({
  "node_modules/warning/warning.js"(exports, module) {
    "use strict";
    var __DEV__ = true;
    var warning2 = function() {
    };
    if (__DEV__) {
      printWarning = function printWarning2(format, args) {
        var len = arguments.length;
        args = new Array(len > 1 ? len - 1 : 0);
        for (var key = 1; key < len; key++) {
          args[key - 1] = arguments[key];
        }
        var argIndex = 0;
        var message = "Warning: " + format.replace(/%s/g, function() {
          return args[argIndex++];
        });
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
      warning2 = function(condition, format, args) {
        var len = arguments.length;
        args = new Array(len > 2 ? len - 2 : 0);
        for (var key = 2; key < len; key++) {
          args[key - 2] = arguments[key];
        }
        if (format === void 0) {
          throw new Error(
            "`warning(condition, format, ...args)` requires a warning message argument"
          );
        }
        if (!condition) {
          printWarning.apply(null, [format].concat(args));
        }
      };
    }
    var printWarning;
    module.exports = warning2;
  }
});

// node_modules/react-date-picker/dist/DatePicker.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var import_react4 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);

// node_modules/make-event-props/dist/index.js
var clipboardEvents = ["onCopy", "onCut", "onPaste"];
var compositionEvents = [
  "onCompositionEnd",
  "onCompositionStart",
  "onCompositionUpdate"
];
var focusEvents = ["onFocus", "onBlur"];
var formEvents = ["onInput", "onInvalid", "onReset", "onSubmit"];
var imageEvents = ["onLoad", "onError"];
var keyboardEvents = ["onKeyDown", "onKeyPress", "onKeyUp"];
var mediaEvents = [
  "onAbort",
  "onCanPlay",
  "onCanPlayThrough",
  "onDurationChange",
  "onEmptied",
  "onEncrypted",
  "onEnded",
  "onError",
  "onLoadedData",
  "onLoadedMetadata",
  "onLoadStart",
  "onPause",
  "onPlay",
  "onPlaying",
  "onProgress",
  "onRateChange",
  "onSeeked",
  "onSeeking",
  "onStalled",
  "onSuspend",
  "onTimeUpdate",
  "onVolumeChange",
  "onWaiting"
];
var mouseEvents = [
  "onClick",
  "onContextMenu",
  "onDoubleClick",
  "onMouseDown",
  "onMouseEnter",
  "onMouseLeave",
  "onMouseMove",
  "onMouseOut",
  "onMouseOver",
  "onMouseUp"
];
var dragEvents = [
  "onDrag",
  "onDragEnd",
  "onDragEnter",
  "onDragExit",
  "onDragLeave",
  "onDragOver",
  "onDragStart",
  "onDrop"
];
var selectionEvents = ["onSelect"];
var touchEvents = ["onTouchCancel", "onTouchEnd", "onTouchMove", "onTouchStart"];
var pointerEvents = [
  "onPointerDown",
  "onPointerMove",
  "onPointerUp",
  "onPointerCancel",
  "onGotPointerCapture",
  "onLostPointerCapture",
  "onPointerEnter",
  "onPointerLeave",
  "onPointerOver",
  "onPointerOut"
];
var uiEvents = ["onScroll"];
var wheelEvents = ["onWheel"];
var animationEvents = [
  "onAnimationStart",
  "onAnimationEnd",
  "onAnimationIteration"
];
var transitionEvents = ["onTransitionEnd"];
var otherEvents = ["onToggle"];
var changeEvents = ["onChange"];
var allEvents = [
  ...clipboardEvents,
  ...compositionEvents,
  ...focusEvents,
  ...formEvents,
  ...imageEvents,
  ...keyboardEvents,
  ...mediaEvents,
  ...mouseEvents,
  ...dragEvents,
  ...selectionEvents,
  ...touchEvents,
  ...pointerEvents,
  ...uiEvents,
  ...wheelEvents,
  ...animationEvents,
  ...transitionEvents,
  ...changeEvents,
  ...otherEvents
];
function makeEventProps(props, getArgs) {
  const eventProps = {};
  for (const eventName of allEvents) {
    const eventHandler = props[eventName];
    if (!eventHandler) {
      continue;
    }
    if (getArgs) {
      eventProps[eventName] = (event) => eventHandler(event, getArgs(eventName));
    } else {
      eventProps[eventName] = eventHandler;
    }
  }
  return eventProps;
}

// node_modules/react-fit/dist/Fit.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react = __toESM(require_react(), 1);

// node_modules/detect-element-overflow/dist/index.js
function getRect(element) {
  return element.getBoundingClientRect();
}
function detectElementOverflow(element, container) {
  return {
    get collidedTop() {
      return getRect(element).top < getRect(container).top;
    },
    get collidedBottom() {
      return getRect(element).bottom > getRect(container).bottom;
    },
    get collidedLeft() {
      return getRect(element).left < getRect(container).left;
    },
    get collidedRight() {
      return getRect(element).right > getRect(container).right;
    },
    get overflowTop() {
      return getRect(container).top - getRect(element).top;
    },
    get overflowBottom() {
      return getRect(element).bottom - getRect(container).bottom;
    },
    get overflowLeft() {
      return getRect(container).left - getRect(element).left;
    },
    get overflowRight() {
      return getRect(element).right - getRect(container).right;
    }
  };
}

// node_modules/react-fit/dist/Fit.js
var import_warning = __toESM(require_warning(), 1);
var __rest = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var isBrowser = typeof window !== "undefined";
var isMutationObserverSupported = isBrowser && "MutationObserver" in window;
function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
function findScrollContainer(element) {
  let parent = element.parentElement;
  while (parent) {
    const { overflow } = window.getComputedStyle(parent);
    if (overflow.split(" ").every((o) => o === "auto" || o === "scroll")) {
      return parent;
    }
    parent = parent.parentElement;
  }
  return document.documentElement;
}
function alignAxis({ axis, container, element, invertAxis, scrollContainer, secondary, spacing }) {
  const style = window.getComputedStyle(element);
  const parent = container.parentElement;
  if (!parent) {
    return;
  }
  const scrollContainerCollisions = detectElementOverflow(parent, scrollContainer);
  const documentCollisions = detectElementOverflow(parent, document.documentElement);
  const isX = axis === "x";
  const startProperty = isX ? "left" : "top";
  const endProperty = isX ? "right" : "bottom";
  const sizeProperty = isX ? "width" : "height";
  const overflowStartProperty = `overflow${capitalize(startProperty)}`;
  const overflowEndProperty = `overflow${capitalize(endProperty)}`;
  const scrollProperty = `scroll${capitalize(startProperty)}`;
  const uppercasedSizeProperty = capitalize(sizeProperty);
  const offsetSizeProperty = `offset${uppercasedSizeProperty}`;
  const clientSizeProperty = `client${uppercasedSizeProperty}`;
  const minSizeProperty = `min-${sizeProperty}`;
  const scrollbarWidth = scrollContainer[offsetSizeProperty] - scrollContainer[clientSizeProperty];
  const startSpacing = typeof spacing === "object" ? spacing[startProperty] : spacing;
  let availableStartSpace = -Math.max(scrollContainerCollisions[overflowStartProperty], documentCollisions[overflowStartProperty] + document.documentElement[scrollProperty]) - startSpacing;
  const endSpacing = typeof spacing === "object" ? spacing[endProperty] : spacing;
  let availableEndSpace = -Math.max(scrollContainerCollisions[overflowEndProperty], documentCollisions[overflowEndProperty] - document.documentElement[scrollProperty]) - endSpacing - scrollbarWidth;
  if (secondary) {
    availableStartSpace += parent[clientSizeProperty];
    availableEndSpace += parent[clientSizeProperty];
  }
  const offsetSize = element[offsetSizeProperty];
  function displayStart() {
    element.style[startProperty] = "auto";
    element.style[endProperty] = secondary ? "0" : "100%";
  }
  function displayEnd() {
    element.style[startProperty] = secondary ? "0" : "100%";
    element.style[endProperty] = "auto";
  }
  function displayIfFits(availableSpace, display) {
    const fits2 = offsetSize <= availableSpace;
    if (fits2) {
      display();
    }
    return fits2;
  }
  function displayStartIfFits() {
    return displayIfFits(availableStartSpace, displayStart);
  }
  function displayEndIfFits() {
    return displayIfFits(availableEndSpace, displayEnd);
  }
  function displayWhereverShrinkedFits() {
    const moreSpaceStart = availableStartSpace > availableEndSpace;
    const rawMinSize = style.getPropertyValue(minSizeProperty);
    const minSize = rawMinSize ? Number.parseInt(rawMinSize, 10) : null;
    function shrinkToSize(size) {
      (0, import_warning.default)(!minSize || size >= minSize, `<Fit />'s child will not fit anywhere with its current ${minSizeProperty} of ${minSize}px.`);
      const newSize = Math.max(size, minSize || 0);
      (0, import_warning.default)(false, `<Fit />'s child needed to have its ${sizeProperty} decreased to ${newSize}px.`);
      element.style[sizeProperty] = `${newSize}px`;
    }
    if (moreSpaceStart) {
      shrinkToSize(availableStartSpace);
      displayStart();
    } else {
      shrinkToSize(availableEndSpace);
      displayEnd();
    }
  }
  let fits;
  if (invertAxis) {
    fits = displayStartIfFits() || displayEndIfFits();
  } else {
    fits = displayEndIfFits() || displayStartIfFits();
  }
  if (!fits) {
    displayWhereverShrinkedFits();
  }
}
function alignMainAxis(args) {
  alignAxis(args);
}
function alignSecondaryAxis(args) {
  alignAxis(Object.assign(Object.assign({}, args), { axis: args.axis === "x" ? "y" : "x", secondary: true }));
}
function alignBothAxis(args) {
  const { invertAxis, invertSecondaryAxis } = args, commonArgs = __rest(args, ["invertAxis", "invertSecondaryAxis"]);
  alignMainAxis(Object.assign(Object.assign({}, commonArgs), { invertAxis }));
  alignSecondaryAxis(Object.assign(Object.assign({}, commonArgs), { invertAxis: invertSecondaryAxis }));
}
function Fit({ children, invertAxis, invertSecondaryAxis, mainAxis = "y", spacing = 8 }) {
  const container = (0, import_react.useRef)(void 0);
  const element = (0, import_react.useRef)(void 0);
  const elementWidth = (0, import_react.useRef)(void 0);
  const elementHeight = (0, import_react.useRef)(void 0);
  const scrollContainer = (0, import_react.useRef)(void 0);
  const fit = (0, import_react.useCallback)(() => {
    if (!scrollContainer.current || !container.current || !element.current) {
      return;
    }
    const currentElementWidth = element.current.clientWidth;
    const currentElementHeight = element.current.clientHeight;
    if (elementWidth.current === currentElementWidth && elementHeight.current === currentElementHeight) {
      return;
    }
    elementWidth.current = currentElementWidth;
    elementHeight.current = currentElementHeight;
    const parent = container.current.parentElement;
    if (!parent) {
      return;
    }
    const style = window.getComputedStyle(element.current);
    const { position } = style;
    if (position !== "absolute") {
      element.current.style.position = "absolute";
    }
    const parentStyle = window.getComputedStyle(parent);
    const { position: parentPosition } = parentStyle;
    if (parentPosition !== "relative" && parentPosition !== "absolute") {
      parent.style.position = "relative";
    }
    alignBothAxis({
      axis: mainAxis,
      container: container.current,
      element: element.current,
      invertAxis,
      invertSecondaryAxis,
      scrollContainer: scrollContainer.current,
      spacing
    });
  }, [invertAxis, invertSecondaryAxis, mainAxis, spacing]);
  const child = import_react.Children.only(children);
  (0, import_react.useEffect)(() => {
    fit();
    function onMutation() {
      fit();
    }
    if (isMutationObserverSupported && element.current) {
      const mutationObserver = new MutationObserver(onMutation);
      mutationObserver.observe(element.current, {
        attributes: true,
        attributeFilter: ["class", "style"]
      });
    }
  }, [fit]);
  function assignRefs(domElement) {
    if (!domElement || !(domElement instanceof HTMLElement)) {
      return;
    }
    element.current = domElement;
    scrollContainer.current = findScrollContainer(domElement);
  }
  return (0, import_jsx_runtime.jsx)("span", { ref: (domContainer) => {
    if (!domContainer) {
      return;
    }
    container.current = domContainer;
    const domElement = domContainer === null || domContainer === void 0 ? void 0 : domContainer.firstElementChild;
    assignRefs(domElement);
  }, style: { display: "contents" }, children: child });
}

// node_modules/react-fit/dist/index.js
var dist_default3 = Fit;

// node_modules/react-date-picker/dist/DateInput.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_react3 = __toESM(require_react(), 1);

// node_modules/react-date-picker/dist/DateInput/DayInput.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);

// node_modules/react-date-picker/dist/DateInput/Input.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react2 = __toESM(require_react(), 1);

// node_modules/update-input-width/dist/esm/index.js
var allowedVariants = ["normal", "small-caps"];
function getFontShorthand(element) {
  if (!element) {
    return "";
  }
  var style = window.getComputedStyle(element);
  if (style.font) {
    return style.font;
  }
  var isFontDefined = style.fontFamily !== "";
  if (!isFontDefined) {
    return "";
  }
  var fontVariant = allowedVariants.includes(style.fontVariant) ? style.fontVariant : "normal";
  return "".concat(style.fontStyle, " ").concat(fontVariant, " ").concat(style.fontWeight, " ").concat(style.fontSize, " / ").concat(style.lineHeight, " ").concat(style.fontFamily);
}
var cachedCanvas;
function measureText(text, font) {
  var canvas = cachedCanvas || (cachedCanvas = document.createElement("canvas"));
  var context = canvas.getContext("2d");
  if (!context) {
    return null;
  }
  context.font = font;
  var width = context.measureText(text).width;
  return Math.ceil(width);
}
function updateInputWidth(element) {
  if (typeof document === "undefined" || !element) {
    return null;
  }
  var font = getFontShorthand(element);
  var text = element.value || element.placeholder;
  var width = measureText(text, font);
  if (width === null) {
    return null;
  }
  element.style.width = "".concat(width, "px");
  return width;
}
var esm_default = updateInputWidth;

// node_modules/react-date-picker/dist/DateInput/Input.js
var isBrowser2 = typeof window !== "undefined";
var useIsomorphicLayoutEffect = isBrowser2 ? import_react2.useLayoutEffect : import_react2.useEffect;
var isIEOrEdgeLegacy = isBrowser2 && /(MSIE|Trident\/|Edge\/)/.test(navigator.userAgent);
var isFirefox = isBrowser2 && /Firefox/.test(navigator.userAgent);
function onFocus(event) {
  const { target } = event;
  if (isIEOrEdgeLegacy) {
    requestAnimationFrame(() => target.select());
  } else {
    target.select();
  }
}
function updateInputWidthOnLoad(element) {
  if (document.readyState === "complete") {
    return;
  }
  function onLoad() {
    esm_default(element);
  }
  window.addEventListener("load", onLoad);
}
function updateInputWidthOnFontLoad(element) {
  if (!document.fonts) {
    return;
  }
  const font = getFontShorthand(element);
  if (!font) {
    return;
  }
  const isFontLoaded = document.fonts.check(font);
  if (isFontLoaded) {
    return;
  }
  function onLoadingDone() {
    esm_default(element);
  }
  document.fonts.addEventListener("loadingdone", onLoadingDone);
}
function getSelectionString(input) {
  if (input && "selectionStart" in input && input.selectionStart !== null && "selectionEnd" in input && input.selectionEnd !== null) {
    return input.value.slice(input.selectionStart, input.selectionEnd);
  }
  if ("getSelection" in window) {
    const selection = window.getSelection();
    return selection === null || selection === void 0 ? void 0 : selection.toString();
  }
  return null;
}
function makeOnKeyPress(maxLength) {
  if (maxLength === null) {
    return void 0;
  }
  return function onKeyPress(event) {
    if (isFirefox) {
      return;
    }
    const { key, target: input } = event;
    const { value } = input;
    const isNumberKey = key.length === 1 && /\d/.test(key);
    const selection = getSelectionString(input);
    if (!isNumberKey || !(selection || value.length < maxLength)) {
      event.preventDefault();
    }
  };
}
function Input({ ariaLabel, autoFocus, className, disabled, inputRef, max, min, name, nameForClass, onChange, onKeyDown, onKeyUp, placeholder = "--", required, showLeadingZeros, step, value }) {
  useIsomorphicLayoutEffect(() => {
    if (!inputRef || !inputRef.current) {
      return;
    }
    esm_default(inputRef.current);
    updateInputWidthOnLoad(inputRef.current);
    updateInputWidthOnFontLoad(inputRef.current);
  }, [inputRef, value]);
  const hasLeadingZero = showLeadingZeros && value && Number(value) < 10 && (value === "0" || !value.toString().startsWith("0"));
  const maxLength = max ? max.toString().length : null;
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [hasLeadingZero ? (0, import_jsx_runtime2.jsx)("span", { className: `${className}__leadingZero`, children: "0" }) : null, (0, import_jsx_runtime2.jsx)("input", {
    "aria-label": ariaLabel,
    autoComplete: "off",
    // biome-ignore lint/a11y/noAutofocus: This is up to developers' decision
    autoFocus,
    className: clsx_default(`${className}__input`, `${className}__${nameForClass || name}`, hasLeadingZero && `${className}__input--hasLeadingZero`),
    "data-input": "true",
    disabled,
    inputMode: "numeric",
    max,
    min,
    name,
    onChange,
    onFocus,
    onKeyDown,
    onKeyPress: makeOnKeyPress(maxLength),
    onKeyUp: (event) => {
      esm_default(event.target);
      if (onKeyUp) {
        onKeyUp(event);
      }
    },
    placeholder,
    // Assertion is needed for React 18 compatibility
    ref: inputRef,
    required,
    step,
    type: "number",
    value: value !== null ? value : ""
  })] });
}

// node_modules/react-date-picker/dist/shared/utils.js
function between(value, min, max) {
  if (min && min > value) {
    return min;
  }
  if (max && max < value) {
    return max;
  }
  return value;
}
function isValidNumber(num) {
  return num !== null && num !== false && !Number.isNaN(Number(num));
}
function safeMin(...args) {
  return Math.min(...args.filter(isValidNumber));
}
function safeMax(...args) {
  return Math.max(...args.filter(isValidNumber));
}

// node_modules/react-date-picker/dist/DateInput/DayInput.js
function DayInput({ maxDate, minDate, month, year, ...otherProps }) {
  const currentMonthMaxDays = (() => {
    if (!month) {
      return 31;
    }
    return getDaysInMonth(new Date(Number(year), Number(month) - 1, 1));
  })();
  function isSameMonth(date) {
    return year === getYear(date).toString() && month === getMonthHuman(date).toString();
  }
  const maxDay = safeMin(currentMonthMaxDays, maxDate && isSameMonth(maxDate) && getDate(maxDate));
  const minDay = safeMax(1, minDate && isSameMonth(minDate) && getDate(minDate));
  return (0, import_jsx_runtime3.jsx)(Input, { max: maxDay, min: minDay, name: "day", ...otherProps });
}

// node_modules/react-date-picker/dist/DateInput/MonthInput.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
function MonthInput({ maxDate, minDate, year, ...otherProps }) {
  function isSameYear(date) {
    return date && year === getYear(date).toString();
  }
  const maxMonth = safeMin(12, maxDate && isSameYear(maxDate) && getMonthHuman(maxDate));
  const minMonth = safeMax(1, minDate && isSameYear(minDate) && getMonthHuman(minDate));
  return (0, import_jsx_runtime4.jsx)(Input, { max: maxMonth, min: minMonth, name: "month", ...otherProps });
}

// node_modules/react-date-picker/dist/DateInput/MonthSelect.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);

// node_modules/react-date-picker/dist/shared/dateFormatter.js
var formatterCache = /* @__PURE__ */ new Map();
function getFormatter(options) {
  return function formatter(locale, date) {
    const localeWithDefault = locale || dist_default();
    if (!formatterCache.has(localeWithDefault)) {
      formatterCache.set(localeWithDefault, /* @__PURE__ */ new Map());
    }
    const formatterCacheLocale = formatterCache.get(localeWithDefault);
    if (!formatterCacheLocale.has(options)) {
      formatterCacheLocale.set(options, new Intl.DateTimeFormat(localeWithDefault || void 0, options).format);
    }
    return formatterCacheLocale.get(options)(date);
  };
}
function toSafeHour(date) {
  const safeDate = new Date(date);
  return new Date(safeDate.setHours(12));
}
function getSafeFormatter(options) {
  return (locale, date) => getFormatter(options)(locale, toSafeHour(date));
}
var formatMonthOptions = { month: "long" };
var formatShortMonthOptions = { month: "short" };
var formatMonth = getSafeFormatter(formatMonthOptions);
var formatShortMonth = getSafeFormatter(formatShortMonthOptions);

// node_modules/react-date-picker/dist/DateInput/MonthSelect.js
function MonthSelect({ ariaLabel, autoFocus, className, disabled, inputRef, locale, maxDate, minDate, onChange, onKeyDown, placeholder = "--", required, short, value, year }) {
  function isSameYear(date) {
    return date && year === getYear(date).toString();
  }
  const maxMonth = safeMin(12, maxDate && isSameYear(maxDate) && getMonthHuman(maxDate));
  const minMonth = safeMax(1, minDate && isSameYear(minDate) && getMonthHuman(minDate));
  const dates = [...Array(12)].map((_el, index) => new Date(2019, index, 1));
  const name = "month";
  const formatter = short ? formatShortMonth : formatMonth;
  return (0, import_jsx_runtime5.jsxs)("select", {
    "aria-label": ariaLabel,
    // biome-ignore lint/a11y/noAutofocus: This is up to developers' decision
    autoFocus,
    className: clsx_default(`${className}__input`, `${className}__${name}`),
    "data-input": "true",
    "data-select": "true",
    disabled,
    name,
    onChange,
    onKeyDown,
    // Assertion is needed for React 18 compatibility
    ref: inputRef,
    required,
    value: value !== null ? value : "",
    children: [!value && (0, import_jsx_runtime5.jsx)("option", { value: "", children: placeholder }), dates.map((date) => {
      const month = getMonthHuman(date);
      const disabled2 = month < minMonth || month > maxMonth;
      return (0, import_jsx_runtime5.jsx)("option", { disabled: disabled2, value: month, children: formatter(locale, date) }, month);
    })]
  });
}

// node_modules/react-date-picker/dist/DateInput/NativeInput.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
function NativeInput({ ariaLabel, disabled, maxDate, minDate, name, onChange, required, value, valueType }) {
  const nativeInputType = (() => {
    switch (valueType) {
      case "decade":
      case "year":
        return "number";
      case "month":
        return "month";
      case "day":
        return "date";
      default:
        throw new Error("Invalid valueType");
    }
  })();
  const nativeValueParser = (() => {
    switch (valueType) {
      case "decade":
      case "year":
        return getYear;
      case "month":
        return getISOLocalMonth;
      case "day":
        return getISOLocalDate;
      default:
        throw new Error("Invalid valueType");
    }
  })();
  function stopPropagation(event) {
    event.stopPropagation();
  }
  return (0, import_jsx_runtime6.jsx)("input", { "aria-label": ariaLabel, disabled, hidden: true, max: maxDate ? nativeValueParser(maxDate) : void 0, min: minDate ? nativeValueParser(minDate) : void 0, name, onChange, onFocus: stopPropagation, required, style: {
    visibility: "hidden",
    position: "absolute",
    zIndex: "-999"
  }, type: nativeInputType, value: value ? nativeValueParser(value) : "" });
}

// node_modules/react-date-picker/dist/DateInput/YearInput.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
function YearInput({ maxDate, minDate, placeholder = "----", valueType, ...otherProps }) {
  const maxYear = safeMin(275760, maxDate && getYear(maxDate));
  const minYear = safeMax(1, minDate && getYear(minDate));
  const yearStep = (() => {
    if (valueType === "century") {
      return 10;
    }
    return 1;
  })();
  return (0, import_jsx_runtime7.jsx)(Input, { max: maxYear, min: minYear, name: "year", placeholder, step: yearStep, ...otherProps });
}

// node_modules/react-date-picker/dist/Divider.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
function Divider({ children }) {
  return (0, import_jsx_runtime8.jsx)("span", { className: "react-date-picker__inputGroup__divider", children });
}

// node_modules/react-date-picker/dist/shared/dates.js
function getBegin(rangeType, date) {
  switch (rangeType) {
    case "decade":
      return getDecadeStart(date);
    case "year":
      return getYearStart(date);
    case "month":
      return getMonthStart(date);
    case "day":
      return getDayStart(date);
    default:
      throw new Error(`Invalid rangeType: ${rangeType}`);
  }
}
function getEnd(rangeType, date) {
  switch (rangeType) {
    case "decade":
      return getDecadeEnd(date);
    case "year":
      return getYearEnd(date);
    case "month":
      return getMonthEnd(date);
    case "day":
      return getDayEnd(date);
    default:
      throw new Error(`Invalid rangeType: ${rangeType}`);
  }
}

// node_modules/react-date-picker/dist/DateInput.js
var getFormatterOptionsCache = {};
var defaultMinDate = /* @__PURE__ */ new Date();
defaultMinDate.setFullYear(1, 0, 1);
defaultMinDate.setHours(0, 0, 0, 0);
var defaultMaxDate = /* @__PURE__ */ new Date(864e13);
var allViews = ["century", "decade", "year", "month"];
var allValueTypes = [...allViews.slice(1), "day"];
function toDate(value) {
  if (value instanceof Date) {
    return value;
  }
  return new Date(value);
}
function getValueType(view) {
  const index = allViews.indexOf(view);
  return allValueTypes[index];
}
function getValue(value, index) {
  const rawValue = Array.isArray(value) ? value[index] : value;
  if (!rawValue) {
    return null;
  }
  const valueDate = toDate(rawValue);
  if (Number.isNaN(valueDate.getTime())) {
    throw new Error(`Invalid date: ${value}`);
  }
  return valueDate;
}
function getDetailValue({ value, minDate, maxDate, maxDetail }, index) {
  const valuePiece = getValue(value, index);
  if (!valuePiece) {
    return null;
  }
  const valueType = getValueType(maxDetail);
  const detailValueFrom = (() => {
    switch (index) {
      case 0:
        return getBegin(valueType, valuePiece);
      case 1:
        return getEnd(valueType, valuePiece);
      default:
        throw new Error(`Invalid index value: ${index}`);
    }
  })();
  return between(detailValueFrom, minDate, maxDate);
}
var getDetailValueFrom = (args) => getDetailValue(args, 0);
var getDetailValueTo = (args) => getDetailValue(args, 1);
var getDetailValueArray = (args) => [getDetailValueFrom, getDetailValueTo].map((fn) => fn(args));
function isInternalInput(element) {
  return element.dataset.input === "true";
}
function findInput(element, property) {
  let nextElement = element;
  do {
    nextElement = nextElement[property];
  } while (nextElement && !isInternalInput(nextElement));
  return nextElement;
}
function focus(element) {
  if (element) {
    element.focus();
  }
}
function renderCustomInputs(placeholder, elementFunctions, allowMultipleInstances) {
  const usedFunctions = [];
  const pattern = new RegExp(Object.keys(elementFunctions).map((el) => `${el}+`).join("|"), "g");
  const matches = placeholder.match(pattern);
  return placeholder.split(pattern).reduce((arr, element, index) => {
    const divider = element && // biome-ignore lint/suspicious/noArrayIndexKey: index is stable here
    (0, import_jsx_runtime9.jsx)(Divider, { children: element }, `separator_${index}`);
    arr.push(divider);
    const currentMatch = matches === null || matches === void 0 ? void 0 : matches[index];
    if (currentMatch) {
      const renderFunction = elementFunctions[currentMatch] || elementFunctions[Object.keys(elementFunctions).find((elementFunction) => currentMatch.match(elementFunction))];
      if (!renderFunction) {
        return arr;
      }
      if (!allowMultipleInstances && usedFunctions.includes(renderFunction)) {
        arr.push(currentMatch);
      } else {
        arr.push(renderFunction(currentMatch, index));
        usedFunctions.push(renderFunction);
      }
    }
    return arr;
  }, []);
}
function DateInput({ autoFocus, className, dayAriaLabel, dayPlaceholder, disabled, format, isCalendarOpen: isCalendarOpenProps = null, locale, maxDate, maxDetail = "month", minDate, monthAriaLabel, monthPlaceholder, name = "date", nativeInputAriaLabel, onChange: onChangeProps, onInvalidChange, required, returnValue = "start", showLeadingZeros, value: valueProps, yearAriaLabel, yearPlaceholder }) {
  const [year, setYear] = (0, import_react3.useState)(null);
  const [month, setMonth] = (0, import_react3.useState)(null);
  const [day, setDay] = (0, import_react3.useState)(null);
  const [value, setValue] = (0, import_react3.useState)(null);
  const yearInput = (0, import_react3.useRef)(null);
  const monthInput = (0, import_react3.useRef)(null);
  const monthSelect = (0, import_react3.useRef)(null);
  const dayInput = (0, import_react3.useRef)(null);
  const [isCalendarOpen, setIsCalendarOpen] = (0, import_react3.useState)(isCalendarOpenProps);
  const lastPressedKey = (0, import_react3.useRef)(void 0);
  (0, import_react3.useEffect)(() => {
    setIsCalendarOpen(isCalendarOpenProps);
  }, [isCalendarOpenProps]);
  (0, import_react3.useEffect)(() => {
    const nextValue = getDetailValueFrom({
      value: valueProps,
      minDate,
      maxDate,
      maxDetail
    });
    if (nextValue) {
      setYear(getYear(nextValue).toString());
      setMonth(getMonthHuman(nextValue).toString());
      setDay(getDate(nextValue).toString());
      setValue(nextValue);
    } else {
      setYear(null);
      setMonth(null);
      setDay(null);
      setValue(null);
    }
  }, [
    valueProps,
    minDate,
    maxDate,
    maxDetail,
    // Toggling calendar visibility resets values
    isCalendarOpen
  ]);
  const valueType = getValueType(maxDetail);
  const formatDate = (() => {
    const level = allViews.indexOf(maxDetail);
    const formatterOptions = getFormatterOptionsCache[level] || (() => {
      const options = { year: "numeric" };
      if (level >= 2) {
        options.month = "numeric";
      }
      if (level >= 3) {
        options.day = "numeric";
      }
      getFormatterOptionsCache[level] = options;
      return options;
    })();
    return getFormatter(formatterOptions);
  })();
  function getProcessedValue(value2) {
    const processFunction = (() => {
      switch (returnValue) {
        case "start":
          return getDetailValueFrom;
        case "end":
          return getDetailValueTo;
        case "range":
          return getDetailValueArray;
        default:
          throw new Error("Invalid returnValue.");
      }
    })();
    return processFunction({
      value: value2,
      minDate,
      maxDate,
      maxDetail
    });
  }
  const placeholder = format || (() => {
    const year2 = 2017;
    const monthIndex = 11;
    const day2 = 11;
    const date = new Date(year2, monthIndex, day2);
    const formattedDate = formatDate(locale, date);
    const datePieces = ["year", "month", "day"];
    const datePieceReplacements = ["y", "M", "d"];
    function formatDatePiece(name2, dateToFormat) {
      const formatterOptions = getFormatterOptionsCache[name2] || (() => {
        const options = { [name2]: "numeric" };
        getFormatterOptionsCache[name2] = options;
        return options;
      })();
      return getFormatter(formatterOptions)(locale, dateToFormat).match(/\d{1,}/);
    }
    let placeholder2 = formattedDate;
    datePieces.forEach((datePiece, index) => {
      const match = formatDatePiece(datePiece, date);
      if (match) {
        const formattedDatePiece = match[0];
        const datePieceReplacement = datePieceReplacements[index];
        placeholder2 = placeholder2.replace(formattedDatePiece, datePieceReplacement);
      }
    });
    placeholder2 = placeholder2.replace("17", "y");
    return placeholder2;
  })();
  const divider = (() => {
    const dividers = placeholder.match(/[^0-9a-z]/i);
    return dividers ? dividers[0] : null;
  })();
  function onClick(event) {
    if (event.target === event.currentTarget) {
      const firstInput = event.target.children[1];
      focus(firstInput);
    }
  }
  function onKeyDown(event) {
    lastPressedKey.current = event.key;
    switch (event.key) {
      case "ArrowLeft":
      case "ArrowRight":
      case divider: {
        event.preventDefault();
        const { target: input } = event;
        const property = event.key === "ArrowLeft" ? "previousElementSibling" : "nextElementSibling";
        const nextInput = findInput(input, property);
        focus(nextInput);
        break;
      }
      default:
    }
  }
  function onKeyUp(event) {
    const { key, target: input } = event;
    const isLastPressedKey = lastPressedKey.current === key;
    if (!isLastPressedKey) {
      return;
    }
    const isNumberKey = !Number.isNaN(Number(key));
    if (!isNumberKey) {
      return;
    }
    const max = input.getAttribute("max");
    if (!max) {
      return;
    }
    const { value: value2 } = input;
    if (Number(value2) * 10 > Number(max) || value2.length >= max.length) {
      const property = "nextElementSibling";
      const nextInput = findInput(input, property);
      focus(nextInput);
    }
  }
  function onChangeExternal() {
    if (!onChangeProps) {
      return;
    }
    function filterBoolean(value2) {
      return Boolean(value2);
    }
    const formElements = [
      dayInput.current,
      monthInput.current,
      monthSelect.current,
      yearInput.current
    ].filter(filterBoolean);
    const values = {};
    for (const formElement of formElements) {
      values[formElement.name] = "valueAsNumber" in formElement ? formElement.valueAsNumber : Number(formElement.value);
    }
    const isEveryValueEmpty = formElements.every((formElement) => !formElement.value);
    if (isEveryValueEmpty) {
      onChangeProps(null, false);
      return;
    }
    const isEveryValueFilled = formElements.every((formElement) => formElement.value);
    const isEveryValueValid = formElements.every((formElement) => formElement.validity.valid);
    if (isEveryValueFilled && isEveryValueValid) {
      const year2 = Number(values.year || (/* @__PURE__ */ new Date()).getFullYear());
      const monthIndex = Number(values.month || 1) - 1;
      const day2 = Number(values.day || 1);
      const proposedValue = /* @__PURE__ */ new Date();
      proposedValue.setFullYear(year2, monthIndex, day2);
      proposedValue.setHours(0, 0, 0, 0);
      const processedValue = getProcessedValue(proposedValue);
      onChangeProps(processedValue, false);
      return;
    }
    if (!onInvalidChange) {
      return;
    }
    onInvalidChange();
  }
  function onChange(event) {
    const { name: name2, value: value2 } = event.target;
    switch (name2) {
      case "year":
        setYear(value2);
        break;
      case "month":
        setMonth(value2);
        break;
      case "day":
        setDay(value2);
        break;
    }
    onChangeExternal();
  }
  function onChangeNative(event) {
    const { value: value2 } = event.target;
    if (!onChangeProps) {
      return;
    }
    const processedValue = (() => {
      if (!value2) {
        return null;
      }
      const [yearString, monthString, dayString] = value2.split("-");
      const year2 = Number(yearString);
      const monthIndex = Number(monthString) - 1 || 0;
      const day2 = Number(dayString) || 1;
      const proposedValue = /* @__PURE__ */ new Date();
      proposedValue.setFullYear(year2, monthIndex, day2);
      proposedValue.setHours(0, 0, 0, 0);
      return proposedValue;
    })();
    onChangeProps(processedValue, false);
  }
  const commonInputProps = {
    className,
    disabled,
    maxDate: maxDate || defaultMaxDate,
    minDate: minDate || defaultMinDate,
    onChange,
    onKeyDown,
    onKeyUp,
    // This is only for showing validity when editing
    required: Boolean(required || isCalendarOpen)
  };
  function renderDay(currentMatch, index) {
    if (currentMatch && currentMatch.length > 2) {
      throw new Error(`Unsupported token: ${currentMatch}`);
    }
    const showLeadingZerosFromFormat = currentMatch && currentMatch.length === 2;
    return (0, import_jsx_runtime9.jsx)(DayInput, { ...commonInputProps, ariaLabel: dayAriaLabel, autoFocus: index === 0 && autoFocus, inputRef: dayInput, month, placeholder: dayPlaceholder, showLeadingZeros: showLeadingZerosFromFormat || showLeadingZeros, value: day, year }, "day");
  }
  function renderMonth(currentMatch, index) {
    if (currentMatch && currentMatch.length > 4) {
      throw new Error(`Unsupported token: ${currentMatch}`);
    }
    if (currentMatch.length > 2) {
      return (0, import_jsx_runtime9.jsx)(MonthSelect, { ...commonInputProps, ariaLabel: monthAriaLabel, autoFocus: index === 0 && autoFocus, inputRef: monthSelect, locale, placeholder: monthPlaceholder, short: currentMatch.length === 3, value: month, year }, "month");
    }
    const showLeadingZerosFromFormat = currentMatch && currentMatch.length === 2;
    return (0, import_jsx_runtime9.jsx)(MonthInput, { ...commonInputProps, ariaLabel: monthAriaLabel, autoFocus: index === 0 && autoFocus, inputRef: monthInput, placeholder: monthPlaceholder, showLeadingZeros: showLeadingZerosFromFormat || showLeadingZeros, value: month, year }, "month");
  }
  function renderYear(_currentMatch, index) {
    return (0, import_jsx_runtime9.jsx)(YearInput, { ...commonInputProps, ariaLabel: yearAriaLabel, autoFocus: index === 0 && autoFocus, inputRef: yearInput, placeholder: yearPlaceholder, value: year, valueType }, "year");
  }
  function renderCustomInputsInternal() {
    const elementFunctions = {
      d: renderDay,
      M: renderMonth,
      y: renderYear
    };
    const allowMultipleInstances = typeof format !== "undefined";
    return renderCustomInputs(placeholder, elementFunctions, allowMultipleInstances);
  }
  function renderNativeInput() {
    return (0, import_jsx_runtime9.jsx)(NativeInput, { ariaLabel: nativeInputAriaLabel, disabled, maxDate: maxDate || defaultMaxDate, minDate: minDate || defaultMinDate, name, onChange: onChangeNative, required, value, valueType }, "date");
  }
  return (
    // biome-ignore lint/a11y/useKeyWithClickEvents: This interaction is designed for mouse users only
    // biome-ignore lint/a11y/noStaticElementInteractions: This interaction is designed for mouse users only
    (0, import_jsx_runtime9.jsxs)("div", { className, onClick, children: [renderNativeInput(), renderCustomInputsInternal()] })
  );
}

// node_modules/react-date-picker/dist/DatePicker.js
var baseClassName = "react-date-picker";
var outsideActionEvents = ["mousedown", "focusin", "touchstart"];
var iconProps = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 19,
  height: 19,
  viewBox: "0 0 19 19",
  stroke: "black",
  strokeWidth: 2
};
var CalendarIcon = (0, import_jsx_runtime10.jsxs)("svg", { ...iconProps, "aria-hidden": "true", className: `${baseClassName}__calendar-button__icon ${baseClassName}__button__icon`, children: [(0, import_jsx_runtime10.jsx)("rect", { fill: "none", height: "15", width: "15", x: "2", y: "2" }), (0, import_jsx_runtime10.jsx)("line", { x1: "6", x2: "6", y1: "0", y2: "4" }), (0, import_jsx_runtime10.jsx)("line", { x1: "13", x2: "13", y1: "0", y2: "4" })] });
var ClearIcon = (0, import_jsx_runtime10.jsxs)("svg", { ...iconProps, "aria-hidden": "true", className: `${baseClassName}__clear-button__icon ${baseClassName}__button__icon`, children: [(0, import_jsx_runtime10.jsx)("line", { x1: "4", x2: "15", y1: "4", y2: "15" }), (0, import_jsx_runtime10.jsx)("line", { x1: "15", x2: "4", y1: "4", y2: "15" })] });
function DatePicker(props) {
  const { autoFocus, calendarAriaLabel, calendarIcon = CalendarIcon, className, clearAriaLabel, clearIcon = ClearIcon, closeCalendar: shouldCloseCalendarOnSelect = true, "data-testid": dataTestid, dayAriaLabel, dayPlaceholder, disableCalendar, disabled, format, id, isOpen: isOpenProps = null, locale, maxDate, maxDetail = "month", minDate, monthAriaLabel, monthPlaceholder, name = "date", nativeInputAriaLabel, onCalendarClose, onCalendarOpen, onChange: onChangeProps, onFocus: onFocusProps, onInvalidChange, openCalendarOnFocus = true, required, returnValue = "start", shouldCloseCalendar, shouldOpenCalendar, showLeadingZeros, value, yearAriaLabel, yearPlaceholder, ...otherProps } = props;
  const [isOpen, setIsOpen] = (0, import_react4.useState)(isOpenProps);
  const wrapper = (0, import_react4.useRef)(null);
  const calendarWrapper = (0, import_react4.useRef)(null);
  (0, import_react4.useEffect)(() => {
    setIsOpen(isOpenProps);
  }, [isOpenProps]);
  function openCalendar({ reason }) {
    if (shouldOpenCalendar) {
      if (!shouldOpenCalendar({ reason })) {
        return;
      }
    }
    setIsOpen(true);
    if (onCalendarOpen) {
      onCalendarOpen();
    }
  }
  const closeCalendar = (0, import_react4.useCallback)(({ reason }) => {
    if (shouldCloseCalendar) {
      if (!shouldCloseCalendar({ reason })) {
        return;
      }
    }
    setIsOpen(false);
    if (onCalendarClose) {
      onCalendarClose();
    }
  }, [onCalendarClose, shouldCloseCalendar]);
  function toggleCalendar() {
    if (isOpen) {
      closeCalendar({ reason: "buttonClick" });
    } else {
      openCalendar({ reason: "buttonClick" });
    }
  }
  function onChange(value2, shouldCloseCalendar2 = shouldCloseCalendarOnSelect) {
    if (shouldCloseCalendar2) {
      closeCalendar({ reason: "select" });
    }
    if (onChangeProps) {
      onChangeProps(value2);
    }
  }
  function onFocus2(event) {
    if (onFocusProps) {
      onFocusProps(event);
    }
    if (
      // Internet Explorer still fires onFocus on disabled elements
      disabled || isOpen || !openCalendarOnFocus || event.target.dataset.select === "true"
    ) {
      return;
    }
    openCalendar({ reason: "focus" });
  }
  const onKeyDown = (0, import_react4.useCallback)((event) => {
    if (event.key === "Escape") {
      closeCalendar({ reason: "escape" });
    }
  }, [closeCalendar]);
  function clear() {
    onChange(null);
  }
  function stopPropagation(event) {
    event.stopPropagation();
  }
  const onOutsideAction = (0, import_react4.useCallback)((event) => {
    const { current: wrapperEl } = wrapper;
    const { current: calendarWrapperEl } = calendarWrapper;
    const target = "composedPath" in event ? event.composedPath()[0] : event.target;
    if (target && wrapperEl && !wrapperEl.contains(target) && (!calendarWrapperEl || !calendarWrapperEl.contains(target))) {
      closeCalendar({ reason: "outsideAction" });
    }
  }, [closeCalendar]);
  const handleOutsideActionListeners = (0, import_react4.useCallback)((shouldListen = isOpen) => {
    for (const event of outsideActionEvents) {
      if (shouldListen) {
        document.addEventListener(event, onOutsideAction);
      } else {
        document.removeEventListener(event, onOutsideAction);
      }
    }
    if (shouldListen) {
      document.addEventListener("keydown", onKeyDown);
    } else {
      document.removeEventListener("keydown", onKeyDown);
    }
  }, [isOpen, onOutsideAction, onKeyDown]);
  (0, import_react4.useEffect)(() => {
    handleOutsideActionListeners();
    return () => {
      handleOutsideActionListeners(false);
    };
  }, [handleOutsideActionListeners]);
  function renderInputs() {
    const [valueFrom] = Array.isArray(value) ? value : [value];
    const ariaLabelProps = {
      dayAriaLabel,
      monthAriaLabel,
      nativeInputAriaLabel,
      yearAriaLabel
    };
    const placeholderProps = {
      dayPlaceholder,
      monthPlaceholder,
      yearPlaceholder
    };
    return (0, import_jsx_runtime10.jsxs)("div", { className: `${baseClassName}__wrapper`, children: [(0, import_jsx_runtime10.jsx)(DateInput, { ...ariaLabelProps, ...placeholderProps, autoFocus, className: `${baseClassName}__inputGroup`, disabled, format, isCalendarOpen: isOpen, locale, maxDate, maxDetail, minDate, name, onChange, onInvalidChange, required, returnValue, showLeadingZeros, value: valueFrom }), clearIcon !== null && (0, import_jsx_runtime10.jsx)("button", { "aria-label": clearAriaLabel, className: `${baseClassName}__clear-button ${baseClassName}__button`, disabled, onClick: clear, onFocus: stopPropagation, type: "button", children: typeof clearIcon === "function" ? (0, import_react4.createElement)(clearIcon) : clearIcon }), calendarIcon !== null && !disableCalendar && (0, import_jsx_runtime10.jsx)("button", { "aria-expanded": isOpen || false, "aria-label": calendarAriaLabel, className: `${baseClassName}__calendar-button ${baseClassName}__button`, disabled, onClick: toggleCalendar, onFocus: stopPropagation, type: "button", children: typeof calendarIcon === "function" ? (0, import_react4.createElement)(calendarIcon) : calendarIcon })] });
  }
  function renderCalendar() {
    if (isOpen === null || disableCalendar) {
      return null;
    }
    const { calendarProps, portalContainer, value: value2 } = props;
    const className2 = `${baseClassName}__calendar`;
    const classNames = clsx_default(className2, `${className2}--${isOpen ? "open" : "closed"}`);
    const calendar = (0, import_jsx_runtime10.jsx)(dist_default2, { locale, maxDate, maxDetail, minDate, onChange: (value3) => onChange(value3), value: value2, ...calendarProps });
    return portalContainer ? (0, import_react_dom.createPortal)((0, import_jsx_runtime10.jsx)("div", { ref: calendarWrapper, className: classNames, children: calendar }), portalContainer) : (0, import_jsx_runtime10.jsx)(dist_default3, { children: (0, import_jsx_runtime10.jsx)("div", { ref: (ref) => {
      if (ref && !isOpen) {
        ref.removeAttribute("style");
      }
    }, className: classNames, children: calendar }) });
  }
  const eventProps = (0, import_react4.useMemo)(
    () => makeEventProps(otherProps),
    // biome-ignore lint/correctness/useExhaustiveDependencies: FIXME
    [otherProps]
  );
  return (
    // biome-ignore lint/a11y/noStaticElementInteractions: False positive caused by non interactive wrapper listening for bubbling events
    (0, import_jsx_runtime10.jsxs)("div", { className: clsx_default(baseClassName, `${baseClassName}--${isOpen ? "open" : "closed"}`, `${baseClassName}--${disabled ? "disabled" : "enabled"}`, className), "data-testid": dataTestid, id, ...eventProps, onFocus: onFocus2, ref: wrapper, children: [renderInputs(), renderCalendar()] })
  );
}

// node_modules/react-date-picker/dist/index.js
var dist_default4 = DatePicker;
export {
  DatePicker,
  dist_default4 as default
};
//# sourceMappingURL=react-date-picker.js.map
